<style>
  :root {
    --ai-primary: #225ADF;
    --ai-accent: #2563eb;
    --ai-bg: #ffffff;
    --ai-surface: #ffffff;
    --ai-border: rgba(0,0,0,0.10);
    --ai-text: #111111;
    --ai-subtext: rgba(0,0,0,0.55);
    --ai-shadow: 0 18px 40px rgba(0,0,0,0.18);
    --ai-user-bubble: #225ADF;
    --ai-bot-bubble: #ffffff;
  }

  #ai-support-bot-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--ai-primary);
    color: #fff;
    padding: 12px 18px;
    border-radius: 999px;
    cursor: pointer;
    font-family: Arial, sans-serif;
    z-index: 999999;
    box-shadow: 0 10px 24px rgba(0,0,0,0.20);
  }

  #ai-support-bot-panel {
    position: fixed;
    bottom: 90px;
    right: 20px;
    width: 380px;
    height: 680px;
    background: var(--ai-bg);
    border-radius: 18px;
    box-shadow: var(--ai-shadow);
    font-family: Arial, sans-serif;
    z-index: 999999;
    display: none;
    overflow: hidden;
    border: 1px solid var(--ai-border);
  }

  #ai-support-bot-header {
    padding: 14px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--ai-surface);
  }

  .ai-header-left {
    display: flex;
    align-items: center;
    gap: 10px;
    min-width: 0;
  }

  .ai-header-avatar {
    width: 48px;
    height: 48px;
    border-radius: 999px;
    border: 1px solid var(--ai-border);
    overflow: hidden;
    background: #fff;
    flex: 0 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .ai-header-avatar img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  .ai-header-title {
    font-size: 15px;
    font-weight: 700;
    color: var(--ai-text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 320px;
  }

  .ai-header-btn {
    width: 42px;
    height: 42px;
    font-size: 22px;
    border: none;
    background: transparent;
    cursor: pointer;
    color: var(--ai-text);
    flex: 0 0 auto;
  }

  #ai-support-bot-back {
    width: 42px;
    height: 42px;
    font-size: 20px;
    border: none;
    background: transparent;
    cursor: pointer;
    color: var(--ai-text);
    flex: 0 0 auto;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 0;
  }

  #ai-support-bot-back:hover {
    opacity: 0.7;
  }

  .ai-divider {
    height: 1px;
    background: rgba(0,0,0,0.06);
  }

  #ai-support-bot-messages {
    height: calc(680px - 76px - 1px - 80px);
    padding: 16px;
    overflow-y: auto;
    background: #fbfbfc;
    font-size: 16px;
  }

  .ai-support-msg {
    margin-bottom: 10px;
  }

  .ai-support-msg.user {
    text-align: right;
  }

  .ai-support-bubble {
    display: inline-block;
    padding: 12px 14px;
    border-radius: 16px;
    max-width: 86%;
    background: var(--ai-bot-bubble);
    border: 1px solid rgba(0,0,0,0.06);
    color: var(--ai-text);
    line-height: 1.4;
    white-space: pre-wrap;
  }

  .ai-support-msg.user .ai-support-bubble {
    background: var(--ai-user-bubble);
    color: #fff;
    border-bottom-right-radius: 6px;
    border: 1px solid rgba(0,0,0,0.08);
  }

  .ai-support-msg.bot .ai-support-bubble {
    border-bottom-left-radius: 6px;
  }

  .ai-support-bubble a {
    color: var(--ai-accent);
    text-decoration: underline;
    word-break: break-word;
  }

  #ai-support-bot-typing {
    font-size: 12px;
    color: var(--ai-subtext);
    padding: 6px 16px 2px;
    display: none;
    background: #fbfbfc;
  }

  .ai-support-time {
    margin-top: 4px;
    font-size: 11px;
    color: var(--ai-subtext);
    line-height: 1;
  }

  .ai-support-msg.user .ai-support-time {
    text-align: right;
    padding-right: 4px;
  }

  .ai-support-msg.bot .ai-support-time {
    text-align: left;
    padding-left: 4px;
  }

  .ai-dots {
    display: inline-block;
    margin-left: 6px;
    vertical-align: baseline;
  }

  .ai-dots span {
    display: inline-block;
    width: 4px;
    height: 4px;
    margin: 0 1px;
    border-radius: 50%;
    background: rgba(0,0,0,0.35);
    animation: aiDotPulse 1s infinite ease-in-out;
  }

  .ai-dots span:nth-child(2) { animation-delay: 0.15s; }
  .ai-dots span:nth-child(3) { animation-delay: 0.30s; }

  @keyframes aiDotPulse {
    0%, 80%, 100% { transform: translateY(0); opacity: 0.35; }
    40% { transform: translateY(-2px); opacity: 1; }
  }

  #ai-support-bot-input-area {
    height: 80px;
    padding: 12px 14px 12px;
    border-top: 1px solid rgba(0,0,0,0.06);
    display: flex;
    gap: 12px;
    align-items: center;
    background: var(--ai-surface);
  }

  #ai-support-bot-input {
    flex: 1;
    border-radius: 999px;
    border: 1px solid rgba(0,0,0,0.14);
    padding: 14px 16px;
    font-size: 15px;
    outline: none;
  }

  #ai-support-bot-input:focus {
    border-color: rgba(0,0,0,0.28);
  }

  #ai-support-bot-send {
    width: 48px;
    height: 48px;
    border-radius: 999px;
    border: none;
    background: var(--ai-primary);
    color: #fff;
    cursor: pointer;
    font-size: 18px;
    flex: 0 0 auto;
  }

  #ai-support-bot-send:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  #ai-support-bot-entry {
    padding: 32px 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    height: calc(680px - 76px);
    overflow-y: auto;
    background: var(--ai-bg);
  }

  .ai-entry-title {
    font-size: 20px;
    font-weight: 700;
    color: var(--ai-text);
    margin: 0 0 16px 0;
    line-height: 1.3;
  }

  .ai-entry-disclaimer {
    font-size: 14px;
    color: var(--ai-subtext);
    line-height: 1.5;
    margin: 0 0 32px 0;
    max-width: 300px;
  }

  .ai-entry-primary-btn {
    background: var(--ai-primary);
    color: #fff;
    border: none;
    border-radius: 999px;
    padding: 14px 32px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    margin-bottom: 16px;
    min-width: 200px;
    font-family: Arial, sans-serif;
  }

  .ai-entry-primary-btn:hover {
    opacity: 0.9;
  }

  .ai-entry-secondary-buttons {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    max-width: 300px;
  }

  .ai-entry-secondary-btn {
    background: transparent;
    color: var(--ai-primary);
    border: 1px solid var(--ai-primary);
    border-radius: 8px;
    padding: 10px 16px;
    font-size: 14px;
    cursor: pointer;
    text-align: left;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-family: Arial, sans-serif;
  }

  .ai-entry-secondary-btn:hover {
    background: rgba(34, 90, 223, 0.05);
  }

  .ai-entry-secondary-btn::after {
    content: "→";
    font-size: 16px;
    margin-left: 8px;
  }

  .ai-chat-hidden {
    display: none !important;
  }

  @media (max-width: 480px) {
    #ai-support-bot-panel {
      right: 12px;
      left: 12px;
      width: auto;
    }
  }
</style>

<div id="ai-support-bot-button">Chat met ons</div>

<div id="ai-support-bot-panel" role="dialog" aria-label="Chat widget">
  <div id="ai-support-bot-header">
    <div class="ai-header-left">
      <button id="ai-support-bot-back" aria-label="Back">←</button>
      <div class="ai-header-avatar">
        <img
          id="ai-support-bot-avatar"
          src=""
          width="48"
          height="48"
          alt="Brand logo"
          style="display:none;"
        />
        <svg id="ai-support-bot-avatar-fallback" viewBox="0 0 24 24" fill="none">
          <path d="M12 12.2c2.1 0 3.8-1.7 3.8-3.8S14.1 4.6 12 4.6 8.2 6.3 8.2 8.4 9.9 12.2 12 12.2Z" fill="rgba(0,0,0,0.55)"/>
          <path d="M4.9 19.4c1.9-3 4.4-4.5 7.1-4.5s5.2 1.5 7.1 4.5" stroke="rgba(0,0,0,0.55)" stroke-width="1.8" stroke-linecap="round"/>
        </svg>
      </div>
      <div class="ai-header-title" id="ai-support-bot-title">Advantum AI-assistent</div>
    </div>
    <button class="ai-header-btn" id="ai-support-bot-close" aria-label="Close">×</button>
  </div>

  <div class="ai-divider"></div>

  <div id="ai-support-bot-entry" style="display: none;">
    <h2 class="ai-entry-title" id="ai-entry-title"></h2>
    <p class="ai-entry-disclaimer" id="ai-entry-disclaimer"></p>
    <button class="ai-entry-primary-btn" id="ai-entry-primary-btn"></button>
    <div class="ai-entry-secondary-buttons" id="ai-entry-secondary-buttons"></div>
  </div>

  <div id="ai-support-bot-messages" class="ai-chat-hidden"></div>
  <div id="ai-support-bot-typing" class="ai-chat-hidden">De assistent is aan het typen…</div>

  <div id="ai-support-bot-input-area" class="ai-chat-hidden">
    <input id="ai-support-bot-input" type="text" placeholder="Stuur ons een bericht…" />
    <button id="ai-support-bot-send" type="button" aria-label="Send">➤</button>
  </div>
</div>

<script>
  (function () {
    var backendURL = "https://ai-support-bot-a6n3.onrender.com";
    var clientId = "Advantum";

    var btn = document.getElementById("ai-support-bot-button");
    var panel = document.getElementById("ai-support-bot-panel");
    var closeBtn = document.getElementById("ai-support-bot-close");
    var backBtn = document.getElementById("ai-support-bot-back");
    var messagesEl = document.getElementById("ai-support-bot-messages");
    var inputEl = document.getElementById("ai-support-bot-input");
    var sendBtn = document.getElementById("ai-support-bot-send");
    var typingEl = document.getElementById("ai-support-bot-typing");
    var inputAreaEl = document.getElementById("ai-support-bot-input-area");

    var titleEl = document.getElementById("ai-support-bot-title");
    var avatarImg = document.getElementById("ai-support-bot-avatar");
    var avatarFallback = document.getElementById("ai-support-bot-avatar-fallback");

    var entryScreenEl = document.getElementById("ai-support-bot-entry");
    var entryTitleEl = document.getElementById("ai-entry-title");
    var entryDisclaimerEl = document.getElementById("ai-entry-disclaimer");
    var entryPrimaryBtn = document.getElementById("ai-entry-primary-btn");
    var entrySecondaryButtonsEl = document.getElementById("ai-entry-secondary-buttons");

    var widgetGreeting = "Hallo! Waar kan ik je mee helpen?";
    var entryScreenCfg = null;
    var hasStartedChat = false; // Resets on page load; entry screen shows first on refresh
    var currentView = "entry"; // "entry" or "chat"
    var chatInitialized = false; // Track if chat has been initialized to prevent duplicate greeting
    var supportConfig = { email: null, contactUrl: null, contactUrlMessageParam: "message" }; // Support config from widget-config

    // NEW: stable per-tab sessionId (persists across refresh, clears on tab close)
    var SESSION_ID_KEY = "aiSupportBot_sessionId_" + clientId;
    var storedSessionId = null;
    try { storedSessionId = sessionStorage.getItem(SESSION_ID_KEY); } catch (e) {}
    var sessionId = storedSessionId || ("shopify-" + Math.random().toString(36).slice(2));
    try { sessionStorage.setItem(SESSION_ID_KEY, sessionId); } catch (e) {}

    // NEW: persist chat history across refresh (but clear on tab close)
    // SECURITY: Store only metadata and redacted previews, not full text
    var HISTORY_KEY = "aiSupportBot_history_" + clientId;
    var history = []; // { messageId, sender, timestamp, messageType, preview }
    
    // SECURITY: Redact sensitive data from text before storage
    function redactSensitiveData(text) {
      if (!text || typeof text !== "string") return "";
      
      var redacted = String(text);
      
      // Remove email addresses
      redacted = redacted.replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, "[email]");
      
      // Remove phone numbers (various formats)
      redacted = redacted.replace(/\b(?:\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}\b/g, "[phone]");
      redacted = redacted.replace(/\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, "[phone]");
      
      // Remove numbers longer than 4 digits (likely order numbers, tracking numbers, etc.)
      redacted = redacted.replace(/\b\d{5,}\b/g, "[number]");
      
      // Remove potential credit card patterns (16 digits, possibly with spaces/dashes)
      redacted = redacted.replace(/\b\d{4}[-.\s]?\d{4}[-.\s]?\d{4}[-.\s]?\d{4}\b/g, "[card]");
      
      // Remove potential tracking codes (alphanumeric codes longer than 8 chars)
      redacted = redacted.replace(/\b[A-Z0-9]{9,}\b/g, "[code]");
      
      return redacted;
    }
    
    // SECURITY: Create safe preview (first 80 chars, redacted, no numbers)
    function createSafePreview(text) {
      if (!text || typeof text !== "string") return "";
      
      // Redact sensitive data first
      var redacted = redactSensitiveData(text);
      
      // Take first 80 characters
      var preview = redacted.slice(0, 80);
      
      // If truncated, add ellipsis
      if (redacted.length > 80) {
        preview += "...";
      }
      
      return preview;
    }
    
    // SECURITY: Clear chat history from storage
    function clearChatHistory() {
      try {
        sessionStorage.removeItem(HISTORY_KEY);
        history = [];
      } catch (e) {}
    }

    // NEW: track the in-chat "searching" placeholder so we can remove it
    var pendingEl = null;

    function setCssVar(name, value) {
      if (!value) return;
      document.documentElement.style.setProperty(name, value);
    }

    function applyWidgetConfig(cfg) {
      if (!cfg) return;

      if (cfg.widget && cfg.widget.title) titleEl.textContent = cfg.widget.title;
      if (cfg.widget && cfg.widget.greeting) widgetGreeting = cfg.widget.greeting;

      if (cfg.logoUrl) {
        avatarImg.src = cfg.logoUrl;
        avatarImg.style.display = "block";
        avatarFallback.style.display = "none";
        avatarImg.onerror = function () {
          avatarImg.style.display = "none";
          avatarFallback.style.display = "block";
        };
      }

      if (cfg.colors) {
        setCssVar("--ai-primary", cfg.colors.primary);
        setCssVar("--ai-accent", cfg.colors.accent);
        setCssVar("--ai-bg", cfg.colors.background);
        setCssVar("--ai-user-bubble", cfg.colors.userBubble);
        setCssVar("--ai-bot-bubble", cfg.colors.botBubble);
      }

      if (cfg.entryScreen) {
        entryScreenCfg = cfg.entryScreen;
        renderEntryScreen();
        
        // Initialize view state: if entry screen is enabled and panel is currently open, show entry screen
        // This handles the case where config loads after user already opened the panel
        // If panel opens after config loads, the button click handler will call shouldShowEntryScreen() which will work correctly
        if (entryScreenCfg.enabled && panel && panel.style.display === "block") {
          if (shouldShowEntryScreen()) {
            showEntryView();
          }
        }
      } else {
        // No entryScreen config: ensure chat UI is shown if panel is open (fallback to chat-only mode)
        if (panel && panel.style.display === "block" && !chatInitialized) {
          showChatView();
        }
      }
      
      if (cfg.support) {
        supportConfig = {
          email: cfg.support.email || null,
          contactUrl: cfg.support.contactUrl || null,
          contactUrlMessageParam: cfg.support.contactUrlMessageParam || "message",
        };
      }

      // Post-config confirmation signal: verify config was successfully applied (non-invasive, guarded, never throws)
      try {
        if (!window.__AI_WIDGET_CONFIG_APPLIED__) {
          window.__AI_WIDGET_CONFIG_APPLIED__ = true;
          
          // Log confirmation that config has been applied (after all values are set)
          try {
            var hasStartupConfig = entryScreenCfg && entryScreenCfg.enabled ? true : false;
            var hasLogo = !!(cfg.logoUrl && cfg.logoUrl.trim());
            var hasGreeting = !!(cfg.widget && cfg.widget.greeting && cfg.widget.greeting.trim());
            var configAppliedInfo = {
              clientId: clientId || "unknown",
              hasStartupConfig: hasStartupConfig,
              hasLogo: hasLogo,
              hasGreeting: hasGreeting
            };
            if (typeof console !== "undefined" && typeof console.info === "function") {
              console.info("[Widget] config applied", configAppliedInfo);
            }
          } catch (e) {
            // Silently fail - smoke check must never break widget
          }
        }
      } catch (e) {
        // Silently fail - smoke check must never break widget
      }
    }

    function renderEntryScreen() {
      if (!entryScreenCfg || !entryScreenCfg.enabled) return;

      if (entryScreenCfg.title) entryTitleEl.textContent = entryScreenCfg.title;
      if (entryScreenCfg.disclaimer) entryDisclaimerEl.textContent = entryScreenCfg.disclaimer;

      if (entryScreenCfg.primaryButton && entryScreenCfg.primaryButton.label) {
        entryPrimaryBtn.textContent = entryScreenCfg.primaryButton.label;
      }

      // SECURITY: Clear using textContent-safe method
      while (entrySecondaryButtonsEl.firstChild) {
        entrySecondaryButtonsEl.removeChild(entrySecondaryButtonsEl.firstChild);
      }
      if (entryScreenCfg.secondaryButtons && Array.isArray(entryScreenCfg.secondaryButtons)) {
        for (var i = 0; i < entryScreenCfg.secondaryButtons.length && i < 2; i++) {
          var btnCfg = entryScreenCfg.secondaryButtons[i];
          if (!btnCfg.label || !btnCfg.action) continue;

          var btn = document.createElement("button");
          btn.className = "ai-entry-secondary-btn";
          // SECURITY: Use textContent instead of innerHTML to prevent XSS
          btn.textContent = String(btnCfg.label || "").slice(0, 100); // Limit length
          btn.onclick = function (action, url) {
            return function () {
              handleSecondaryButtonAction(action, url);
            };
          }(btnCfg.action, btnCfg.url);
          entrySecondaryButtonsEl.appendChild(btn);
        }
      }
    }

    function handleSecondaryButtonAction(action, url) {
      if (action === "link" && url) {
        window.open(url, "_blank", "noopener");
      }
    }

    function showEntryView() {
      currentView = "entry";
      if (entryScreenEl) entryScreenEl.style.display = "flex";
      if (messagesEl) messagesEl.classList.add("ai-chat-hidden");
      if (typingEl) typingEl.classList.add("ai-chat-hidden");
      if (inputAreaEl) inputAreaEl.classList.add("ai-chat-hidden");
      if (backBtn) backBtn.style.display = "none";
    }

    function showChatView() {
      currentView = "chat";
      if (entryScreenEl) entryScreenEl.style.display = "none";
      if (messagesEl) messagesEl.classList.remove("ai-chat-hidden");
      if (typingEl) typingEl.classList.remove("ai-chat-hidden");
      if (inputAreaEl) inputAreaEl.classList.remove("ai-chat-hidden");
      if (backBtn && entryScreenCfg && entryScreenCfg.enabled) {
        backBtn.style.display = "flex";
      } else if (backBtn) {
        backBtn.style.display = "none";
      }

      if (!chatInitialized) {
        chatInitialized = true;
        if (messagesEl.children.length === 0) {
          if (history.length > 0) {
            renderHistory();
          } else {
            addMessage(widgetGreeting, "bot", { time: new Date() });
          }
        }
      }

      inputEl.focus();
    }

    function startChat() {
      hasStartedChat = true;
      showChatView();
    }

    function shouldShowEntryScreen() {
      return entryScreenCfg && entryScreenCfg.enabled && !hasStartedChat;
    }

    async function loadConfig() {
      try {
        var res = await fetch(backendURL + "/widget-config?client=" + encodeURIComponent(clientId));
        if (!res.ok) {
          // Config load failed: fallback to chat-only mode
          if (panel && panel.style.display === "block" && !chatInitialized) {
            showChatView();
          }
          return;
        }
        var cfg = await res.json();
        applyWidgetConfig(cfg);
      } catch (e) {
        // Config load error: fallback to chat-only mode
        if (panel && panel.style.display === "block" && !chatInitialized) {
          showChatView();
        }
      }
    }

    function linkifyInto(el, text) {
      var s = String(text || "");
      // SECURITY: Validate URLs to prevent dangerous schemes
      function isValidUrl(url) {
        if (!url || typeof url !== "string") return false;
        var lower = url.toLowerCase().trim();
        // Block dangerous schemes
        if (lower.startsWith("javascript:") || 
            lower.startsWith("data:") || 
            lower.startsWith("vbscript:") ||
            lower.startsWith("file:") ||
            lower.startsWith("about:")) {
          return false;
        }
        return true;
      }
      
      var re = /(\bhttps?:\/\/[^\s]+)|(\bwww\.[^\s]+)|(\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b)/gi;
      var last = 0;
      var m;

      while ((m = re.exec(s)) !== null) {
        var start = m.index;
        var end = start + m[0].length;

        if (start > last) {
          el.appendChild(document.createTextNode(s.slice(last, start)));
        }

        var token = m[0];
        
        // SECURITY: Validate token before creating link
        if (!isValidUrl(token) && !token.includes("@")) {
          // Invalid URL, render as plain text
          el.appendChild(document.createTextNode(token));
          last = end;
          continue;
        }
        
        var a = document.createElement("a");
        a.target = "_blank";
        a.rel = "noopener noreferrer"; // SECURITY: Add noreferrer

        if (token.toLowerCase().startsWith("http://") || token.toLowerCase().startsWith("https://")) {
          a.href = token;
          // SECURITY: Use textContent and limit length
          a.textContent = String(token).slice(0, 200);
        } else if (token.toLowerCase().startsWith("www.")) {
          a.href = "https://" + token;
          a.textContent = String(token).slice(0, 200);
        } else {
          // Email address
          a.href = "mailto:" + token;
          a.textContent = String(token).slice(0, 200);
        }

        el.appendChild(a);
        last = end;
      }

      if (last < s.length) {
        el.appendChild(document.createTextNode(s.slice(last)));
      }
    }

    function formatTime(d) {
      try {
        return new Intl.DateTimeFormat("nl-NL", { hour: "2-digit", minute: "2-digit" }).format(d);
      } catch (e) {
        var hh = String(d.getHours()).padStart(2, "0");
        var mm = String(d.getMinutes()).padStart(2, "0");
        return hh + ":" + mm;
      }
    }

    // SECURITY: Save chat snapshot (metadata only, redacted preview)
    function saveChatSnapshot(text, sender, messageType) {
      if (!text || typeof text !== "string") return;
      if (sender !== "user" && sender !== "bot") return;
      
      // Create safe preview (redacted, truncated)
      var preview = createSafePreview(text);
      
      // Generate message ID
      var messageId = "msg-" + Date.now() + "-" + Math.random().toString(36).slice(2, 9);
      
      // Determine message type if not provided
      if (!messageType) {
        messageType = "normal";
        if (text.toLowerCase().includes("escalat") || text.toLowerCase().includes("support team")) {
          messageType = "escalation";
        } else if (text.toLowerCase().includes("error") || text.toLowerCase().includes("fout")) {
          messageType = "system";
        }
      }
      
      // Store only metadata (preview is already redacted)
      var snapshot = {
        messageId: messageId,
        sender: sender,
        timestamp: Date.now(),
        messageType: messageType,
        preview: preview // Redacted preview (no obfuscation to avoid key persistence issues)
      };
      
      history.push(snapshot);
      
      // Keep only last 50 messages to limit storage
      if (history.length > 50) {
        history = history.slice(-50);
      }
      
      saveHistory();
    }
    
    function saveHistory() {
      try {
        sessionStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      } catch (e) {}
    }

    function loadHistory() {
      try {
        var raw = sessionStorage.getItem(HISTORY_KEY);
        if (!raw) return [];
        var parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        
        // Validate loaded snapshots
        return parsed.filter(function (x) {
          if (!x || typeof x !== "object") return false;
          if (x.sender !== "user" && x.sender !== "bot") return false;
          if (typeof x.timestamp !== "number") return false;
          if (typeof x.messageId !== "string") return false;
          if (typeof x.messageType !== "string") return false;
          if (typeof x.preview !== "string") return false;
          
          return true;
        });
      } catch (e) {
        return [];
      }
    }

    function renderHistory() {
      // SECURITY: Clear using safe method instead of innerHTML
      while (messagesEl.firstChild) {
        messagesEl.removeChild(messagesEl.firstChild);
      }
      for (var i = 0; i < history.length; i++) {
        var m = history[i];
        // Restore from snapshot (show preview with note that full text isn't available)
        var displayText = m.preview || "[Message preview]";
        if (m.messageType === "escalation") {
          displayText = "Support team has been notified. " + displayText;
        }
        addMessage(displayText, m.sender, { time: new Date(m.timestamp), persist: false });
      }
    }

    function renderRichText(el, text) {
      var s = String(text || "");
      // SECURITY: Validate and sanitize URLs to prevent javascript: and data: schemes
      function isValidUrl(url) {
        if (!url || typeof url !== "string") return false;
        var lower = url.toLowerCase().trim();
        // Block dangerous schemes
        if (lower.startsWith("javascript:") || 
            lower.startsWith("data:") || 
            lower.startsWith("vbscript:") ||
            lower.startsWith("file:") ||
            lower.startsWith("about:")) {
          return false;
        }
        // Only allow http, https, and relative URLs
        return lower.startsWith("http://") || 
               lower.startsWith("https://") || 
               lower.startsWith("www.") ||
               lower.startsWith("/");
      }
      
      // Regex to match Markdown links: [label](url)
      // url can be https://..., http://..., or www....
      var markdownLinkRe = /\[([^\]]+)\]\((https?:\/\/[^\s\)]+|www\.[^\s\)]+)\)/g;
      var last = 0;
      var m;
      var hasMatch = false;

      while ((m = markdownLinkRe.exec(s)) !== null) {
        hasMatch = true;
        var start = m.index;
        var end = start + m[0].length;
        var label = m[1];
        var url = m[2];

        // SECURITY: Validate URL before creating link
        if (!isValidUrl(url)) {
          // If URL is invalid, just render as text
          if (start > last) {
            linkifyInto(el, s.slice(last, start));
          }
          el.appendChild(document.createTextNode("[" + label + "]"));
          last = end;
          continue;
        }

        // Append text before the link using linkifyInto
        if (start > last) {
          linkifyInto(el, s.slice(last, start));
        }

        // Create link element
        var a = document.createElement("a");
        // SECURITY: Use textContent to prevent XSS in label
        a.textContent = String(label || "").slice(0, 200); // Limit length
        if (url.toLowerCase().startsWith("www.")) {
          a.href = "https://" + url;
        } else {
          a.href = url;
        }
        a.target = "_blank";
        a.rel = "noopener noreferrer"; // SECURITY: Add noreferrer
        el.appendChild(a);

        last = end;
      }

      // Append remaining text after the last match
      if (last < s.length) {
        linkifyInto(el, s.slice(last));
      } else if (!hasMatch) {
        // If no markdown links found, use linkifyInto for everything
        linkifyInto(el, s);
      }
    }

    // UPDATED: persist messages by default (persist=false for rendering old history)
    function addMessage(text, who, opts) {
      opts = opts || {};
      var wrap = document.createElement("div");
      wrap.className = "ai-support-msg " + who;

      var bubble = document.createElement("div");
      bubble.className = "ai-support-bubble";

      if (who === "user") {
        bubble.textContent = text;
      } else {
        if (opts.isSearching) {
          bubble.textContent = text;
          var dots = document.createElement("span");
          dots.className = "ai-dots";
          // SECURITY: Create elements safely instead of innerHTML
          for (var i = 0; i < 3; i++) {
            var dot = document.createElement("span");
            dots.appendChild(dot);
          }
          bubble.appendChild(dots);
        } else {
          renderRichText(bubble, text);
        }
      }

      wrap.appendChild(bubble);

      var timeEl = document.createElement("div");
      timeEl.className = "ai-support-time";
      timeEl.textContent = formatTime(opts.time || new Date());
      wrap.appendChild(timeEl);

      messagesEl.appendChild(wrap);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      // SECURITY: Persist only metadata and redacted preview (skip when rendering existing history)
      if (opts.persist !== false && !opts.isSearching) {
        var messageType = opts.messageType || "normal";
        saveChatSnapshot(String(text || ""), who, messageType);
      }

      return wrap;
    }

    function showSearching() {
      removeSearching();
      pendingEl = addMessage("Zoeken naar info", "bot", { isSearching: true, time: new Date(), persist: false });
    }

    function removeSearching() {
      if (pendingEl && pendingEl.parentNode) pendingEl.parentNode.removeChild(pendingEl);
      pendingEl = null;
    }
    
    function renderHandoffUI(messageEl, data) {
      if (!messageEl || !data.handoffSummary) return;
      
      // Create summary container
      var summaryContainer = document.createElement("div");
      summaryContainer.className = "ai-handoff-summary";
      summaryContainer.style.cssText = "margin-top: 12px; padding: 12px; background: #f5f5f5; border-radius: 8px; font-size: 13px; white-space: pre-wrap; line-height: 1.5; color: #333;";
      
      var summaryText = document.createElement("div");
      summaryText.textContent = data.handoffSummary;
      summaryContainer.appendChild(summaryText);
      
      // Create buttons container
      var buttonsContainer = document.createElement("div");
      buttonsContainer.className = "ai-handoff-buttons";
      buttonsContainer.style.cssText = "margin-top: 12px; display: flex; gap: 8px; flex-wrap: wrap;";
      
      // Build mailto link if email is available
      if (supportConfig.email) {
        var subject = "Support aanvraag - " + (clientId || "") + " - " + (data.escalateReason || "algemeen");
        var body = data.handoffSummary;
        if (data.requestId) body += "\n\nReferentie: " + data.requestId;
        var mailtoLink = "mailto:" + encodeURIComponent(supportConfig.email) + "?subject=" + encodeURIComponent(subject) + "&body=" + encodeURIComponent(body);
        
        var emailBtn = document.createElement("button");
        emailBtn.className = "ai-handoff-btn";
        emailBtn.textContent = "E-mail support";
        emailBtn.style.cssText = "flex: 1; min-width: 120px; padding: 10px 16px; background: var(--ai-primary, #225ADF); color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer;";
        emailBtn.onclick = function() {
          window.location.href = mailtoLink;
        };
        buttonsContainer.appendChild(emailBtn);
      }
      
      // Build contact form URL if available
      if (supportConfig.contactUrl) {
        var contactUrl = supportConfig.contactUrl;
        if (supportConfig.contactUrlMessageParam && data.handoffSummary) {
          var separator = contactUrl.includes("?") ? "&" : "?";
          contactUrl = contactUrl + separator + encodeURIComponent(supportConfig.contactUrlMessageParam) + "=" + encodeURIComponent(data.handoffSummary + (data.requestId ? "\n\nReferentie: " + data.requestId : ""));
        }
        
        var contactBtn = document.createElement("button");
        contactBtn.className = "ai-handoff-btn";
        contactBtn.textContent = "Contactformulier";
        contactBtn.style.cssText = "flex: 1; min-width: 120px; padding: 10px 16px; background: var(--ai-primary, #225ADF); color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer;";
        contactBtn.onclick = function() {
          window.open(contactUrl, "_blank", "noopener");
        };
        buttonsContainer.appendChild(contactBtn);
      }
      
      // Only append if we have buttons to show
      if (buttonsContainer.children.length > 0) {
        summaryContainer.appendChild(buttonsContainer);
        messageEl.appendChild(summaryContainer);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }
    }

    async function sendMessage() {
      var text = (inputEl.value || "").trim();
      if (!text) return;

      addMessage(text, "user", { time: new Date() });
      inputEl.value = "";

      typingEl.style.display = "none";
      showSearching();

      sendBtn.disabled = true;
      inputEl.disabled = true;

      try {
        var res = await fetch(backendURL + "/chat?client=" + encodeURIComponent(clientId), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: text, sessionId: sessionId })
        });

        var data = await res.json();

        removeSearching();

        var reply = (data && data.reply) ? data.reply : "Er ging iets mis.";
        var messageEl = addMessage(reply, "bot", { time: new Date() });
        
        // Handle escalation to human with handoff buttons
        if (data.escalateToHuman && data.handoffSummary) {
          renderHandoffUI(messageEl, data);
          // SECURITY: Clear chat history on escalation (sensitive data may have been discussed)
          clearChatHistory();
        }
      } catch (e) {
        removeSearching();
        addMessage("Er is een fout opgetreden. Probeer het later opnieuw.", "bot", { 
          time: new Date(),
          messageType: "system"
        });
        // SECURITY: Clear history on hard errors (may indicate security issue)
        clearChatHistory();
      } finally {
        sendBtn.disabled = false;
        inputEl.disabled = false;
        inputEl.focus();
      }
    }

    backBtn.addEventListener("click", function () {
      showEntryView();
    });

    entryPrimaryBtn.addEventListener("click", function () {
      if (entryScreenCfg && entryScreenCfg.primaryButton && entryScreenCfg.primaryButton.action === "openChat") {
        startChat();
      }
    });

    btn.addEventListener("click", function () {
      panel.style.display = (panel.style.display === "block") ? "none" : "block";

      if (panel.style.display === "block") {
        if (shouldShowEntryScreen()) {
          showEntryView();
        } else {
          showChatView();
        }
      }
    });

    closeBtn.addEventListener("click", function () {
      panel.style.display = "none";
    });

    sendBtn.addEventListener("click", sendMessage);

    inputEl.addEventListener("keydown", function (e) {
      if (e.key === "Enter") {
        e.preventDefault();
        if (!sendBtn.disabled) sendMessage();
      }
    });

    // NEW: load history immediately so it is ready on open
    history = loadHistory();

    // Initialize: hide chat UI by default, entry screen will show when enabled after config loads
    // This ensures correct initial state before config is loaded (chat UI hidden until entry screen or chat view is explicitly shown)
    if (messagesEl) messagesEl.classList.add("ai-chat-hidden");
    if (typingEl) typingEl.classList.add("ai-chat-hidden");
    if (inputAreaEl) inputAreaEl.classList.add("ai-chat-hidden");
    // Entry screen starts hidden, will be shown by showEntryView() when config loads if enabled
    // This is set in HTML (style="display: none;") and managed by showEntryView()/showChatView()

    loadConfig();

    // Runtime smoke check: confirm widget loaded successfully (non-invasive, guarded, never throws)
    try {
      if (!window.__AI_WIDGET_SMOKE_CHECK__) {
        window.__AI_WIDGET_SMOKE_CHECK__ = true;
        
        // Log successful script load (config may not be loaded yet, that's OK - we're just confirming script execution)
        // Use setTimeout to be non-blocking and allow config to start loading
        setTimeout(function() {
          try {
            var hasStartupConfig = entryScreenCfg && entryScreenCfg.enabled ? true : false;
            var smokeCheckInfo = {
              clientId: clientId || "unknown",
              hasStartupConfig: hasStartupConfig,
              backendURL: backendURL || "unknown"
            };
            if (typeof console !== "undefined" && typeof console.info === "function") {
              console.info("[Widget] loaded", smokeCheckInfo);
            }
          } catch (e) {
            // Silently fail - smoke check must never break widget
          }
        }, 0);
      }
    } catch (e) {
      // Silently fail - smoke check must never break widget
    }
  })();
</script>